Найти и пересказать:
-------------------------------------------------------------------------------------------------
1 Что такое generics?

Это механизм Java, позволяющий уйти от жесткого определения используемого типа данных.
-------------------------------------------------------------------------------------------------
2 С какими типами работает generics?

Только с ссылочными типами
-------------------------------------------------------------------------------------------------
3 Как работает wildcard extends?

<? extends Type> - конструкция Java, гласящая о возможности использования типа Type или 
любого из его дочерних классов
-------------------------------------------------------------------------------------------------
4 Как работает wildcard для аргументов методов: “?”, “? extends”, “? super”?

Применение wildcard в методах основано на методологии PECS, т.е. Producer Extends Consumer Super
4.1. при применении wildcard: AnyGenericClass<? extends Type> anyGenericClassObject возможно только
получение данных, которыми параметризирован AnyGenericClass (изменение данных не пропустит компилятор).
4.2. при применении wildcard: AnyGenericClass<? super Type> anyGenericClassObject возможно только
изменение данных, которыми параметризирован AnyGenericClass (получение данных возможно только типа Object)
4.3. wildcard <?> аналогичен <? extends Object> и, соответственно, справедливо, указанное в п.4.1
-------------------------------------------------------------------------------------------------
5 Какие имплементации вы знаете interface Collection?

ArrayList, LinkedList, HashSet, LinkedHashSet, TreeSet, Vector, Stack, ArrayDeque, PriorityQueue
-------------------------------------------------------------------------------------------------
6 Какие имплементации вы знаете interface Map?

HashMap, LinkedHashMap, TreeMap, HashTable
-------------------------------------------------------------------------------------------------
7 В чем разница между ArrayList и LinkedList?

Информация в контейнере ArrayList хранится в ячейках массива
Информация в контейнере LinkedList хранится в виде связанного списка.
-------------------------------------------------------------------------------------------------
8 Как устроен HashSet ?

Это контейнер для хранения уникальных данных. Каркасом для хранения информации является HashMap.
Размер по умолчанию этого HashMap - 16 ячеек (bucket-ов). При добавлении нового объекта-элемента 
значения, возвращаемого методом hashCode данного объекта-элемента, вычисляется номер bucket-а, в котором 
осуществляется поиск эквивалентного объекта (newObject.equals(existingObject)).
Если аналогичный объекта находится, то ничего дальше не происходит. В обратном случае в данном bucket-e 
будет хранится ссылка на объект-обертку, в который "завернут" наш добавляемый объект-элемент + информация о его hash-е и 
ссылка на следующий объект-обертку, который был добавлен ранее и в данный bucket.
-------------------------------------------------------------------------------------------------
9 Как устроен HashMap?

Состоит из массива "корзин" (по умолчанию 16 штук)
    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

При вызове метода Map::put происходит вычисление значения метода Map::hash

    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }

Резкльтат этого метода логически складывается с размером массива "корзин"
(n - 1) & hash, тем самым получаем конкретный номер корзины, куда будет сваливаться наш новый элемент
Затем производиться проходка по всем элементам этой корзины и если эквивалентный (на основании
метода equals) ключ не найден, то новый элемент (пара ключ-значение) "оборачивается" в Node, в поле next
записывается ссылка на тот элемент, который до этого был на этом месте в корзине.
При нахождении эквивалентного  ключа, происходит перезапись значения данного элемента.
-------------------------------------------------------------------------------------------------
10 Что такое итераторы в коллекциях?

Итераторы в коллекциях - это имплементированные методы интерфейса Iterator, с помощью которых возможно
осуществлять следующие операции:
10.1. Последовательное чтение элементов контейнера - iterator.next()
10.2. Удаление из контейнера последнего прочитанного элемента - iterator.remove()
10.3. Применение некой функции к непрочитанным элементам коллекции - iterator.forEachRemaining(Consumer<?> apply)
-------------------------------------------------------------------------------------------------
11 Как устроен TreeSet?

TreeSet реализлван на основе TreeMap, поэтому см. п.12
-------------------------------------------------------------------------------------------------
12 Как устроен TreeMap?

Элементы хранятся в виде красно-черного дерева, позволяющий производить бинарный поиск, скорость которого
равна log(n), где n - это количество элемнтов в дереве.
Каждый элемент дерева представляет собой следующую структуру
static final class Entry<K,V> implements Map.Entry<K,V> {
        K key;
        V value;
        Entry<K,V> left;
        Entry<K,V> right;
        Entry<K,V> parent;
        boolean color = BLACK;

Свойства КЧД:
1) Каждый узел окрашен либо в красный, либо в черный цвет 
(в структуре данных узла появляется дополнительное поле – бит цвета).

2) Корень окрашен в черный цвет.

3) Листья(так называемые NULL-узлы) окрашены в черный цвет.

4) Каждый красный узел должен иметь два черных дочерних узла. 
Нужно отметить, что у черного узла могут быть черные дочерние узлы. 
Красные узлы в качестве дочерних могут иметь только черные.

5) Пути от узла к его листьям должны содержать одинаковое количество черных узлов(это черная высота).
-------------------------------------------------------------------------------------------------
13 Как задать сортировку в TreeMap и TreeSet (двумя способами)?

13.1. Класс, который будет хранится в контейнерах TreeMap, TreeSet, должен инмлементировать интерфейс 
Compsrsble<T>
13.2. При создании объектов TreeMap, TreeSet в качестве параметра передавать в конструктор объект
класса, реализующего интерфейс Comparator<T>
-------------------------------------------------------------------------------------------------
14 Зачем нужен interface Comparable?

Для задания алгоритма сортировки экземпляров класса, реализующего данный интерфейс
-------------------------------------------------------------------------------------------------
15 Как задать Immutable List, Set, Map?

В классе, который будет исползоваться в контейнерах необходимо делать поля final и сам класс
тоже final 
-------------------------------------------------------------------------------------------------
